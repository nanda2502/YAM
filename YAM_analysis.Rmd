---
title: "YAM analysis"
author: "Nanda Jafarian"
date: "2024-09-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(igraph)
library(combinat)
library(ggplot2)
library(gridExtra)
library(ggraph)
library(dplyr)
library(grid)
library(cowplot)
``` 



```{r}

calc_total_distance_from_root <- function(data) {
  unique_combinations <- data %>%
    select(num_nodes, adj_mat) %>%
    distinct()
  for (i in seq_len(nrow(unique_combinations))) {
    combination <- unique_combinations[i, ]
    adj_string <- combination[[which(colnames(unique_combinations) == "adj_mat")]]
    num_nodes <- combination[[which(colnames(unique_combinations) == "num_nodes")]]
    
    adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
    adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
    graph <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
    V(graph )$name <- as.character(1:num_nodes)
    all_paths <- list()
    total_distance <- 0
    
    for (node in V(graph)$name) {
      if (node != "1") {
        paths <- all_simple_paths(graph, from="1", to=node, mode="out")
        all_paths[[node]] <- paths
        for (path in paths) {
          total_distance <- total_distance + (length(path) - 1)
        }
      }
    }
    data[data$adj_mat == adj_string, "total_distance"] <- total_distance
  }
  data
}


plotDVByDistance <- function(data, DV, DV_label) {
  average_data <- data %>%
    group_by(adj_mat, strategy, total_distance) %>%
    summarize(avg_DV = mean(!!sym(DV), na.rm = TRUE), .groups = 'drop')

  num_nodes <- data$num_nodes[1]

  plot <- ggplot(average_data, aes(x = total_distance, y = avg_DV, color = as.factor(strategy))) +
    geom_jitter(width = 0.2, size = 1.5) +
    geom_smooth(method = "lm", se = FALSE) +
    labs(title = paste0(DV_label, " by Distance"),
         subtitle = paste0("Number of Nodes: ", num_nodes),
         x = "Total Distance from Root",
         y = DV_label) +
    theme_minimal() +
    scale_color_discrete(name = "Strategy") #+ 
    # scale_y_continuous(
    #   breaks = seq(0, max(average_data$avg_DV) + 1, by = 1),
    #   minor_breaks = seq(0, max(average_data$avg_DV), by = 0.5)
    # )
  
  print(plot)
  return(plot)
}

remove_duplicates <- function(data) {
  unique_graphs <- list()
  unique_indices <- c()
  
  unique_combinations <- unique(data[, c("adj_mat", "num_nodes")])
  
  for (i in seq_len(nrow(unique_combinations))) {
    adj_string <- unique_combinations$adj_mat[i]
    num_nodes <- unique_combinations$num_nodes[i]
    
    # Convert the adjacency string to a numeric vector
    adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
    adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
    
    # Create a graph object
    g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
    
    # Check if the graph is isomorphic to any of the already added unique graphs
    is_duplicate <- any(sapply(unique_graphs, function(unique_g) isomorphic(unique_g, g)))
    
    if (!is_duplicate) {
      unique_graphs <- append(unique_graphs, list(g))
      unique_indices <- c(unique_indices, which(data$adj_mat == adj_string & data$num_nodes == num_nodes))
    }
  }
  
  return(data[unique_indices, ])
}

clean_file <- function(data) {
  num_nodes <- data$num_nodes[1]
  sum_nan <- sum(is.nan(data$step_payoff))
  if (sum_nan > 0) {
    print(paste0("Removing ", sum_nan, " observations that failed not converge."))
  }
  data <- data[!is.nan(data$step_payoff), ]
  sum_short <- sum(data$steps < num_nodes - 1)
  if (sum_short > 0) {
    print(paste0("Removing ", sum_short, " observations that reached the absorbing state in an impossible time."))
  }
  data <- data[data$steps >= num_nodes - 1, ]
}

read_file <- function(num_nodes) {
  data <- read.csv(gzfile(paste0("./output/expected_steps_", num_nodes, ".csv.gz")), stringsAsFactors = FALSE, colClasses = c(adj_mat = "character"))
  data$strategy <- factor(data$strategy, levels = c("RandomLearning", "PayoffBasedLearning", "VygotskianLearning"), labels = c("Random Learning", "Payoff-Based Learning", "Proximal Learning"))
  return(data)
}


data <- read_file(6)
data <- clean_file(data)
data <- remove_duplicates(data)
data <- calc_total_distance_from_root(data)


steps_plot <- plotDVByDistance(data, "steps", "Expected Steps")
payoff_plot <- plotDVByDistance(data[data$alpha >= 0, ], "step_payoff", "Expected Payoff per Step")
transitions_plot <- plotDVByDistance(data[data$total_distance < 20,], "step_transitions", "Expected Success Rate of Learning Attempts")


summary(lm(steps ~ total_distance * strategy, data = data))

library(ggpubr)
data$strategy <- factor(data$strategy, levels = c("RandomLearning", "PayoffBasedLearning", "VygotskianLearning"))
ggplot(data, aes(x = strategy, y = step_transitions, fill = strategy)) +
  geom_bar(stat = "summary", fun = "mean", position = "dodge") +
  stat_summary(fun.data = "mean_cl_normal", geom = "errorbar", width = 0.2, position = position_dodge(0.9)) +
  theme_minimal() +
  labs(title = "Bar Plot with Pairwise Comparisons",
       x = "Strategy",
       y = "Step Transitions") +
  theme(legend.position = "none") +
  stat_compare_means(comparisons = list(c("RandomLearning", "PayoffBasedLearning"),
                                        c("RandomLearning", "VygotskianLearning"),
                                        c("PayoffBasedLearning", "VygotskianLearning")),
                     method = "t.test")
``` 

```{r}
data$adj_mat <- as.factor(data$adj_mat)
data$steps_scaled <- scale(data$steps)
library(brms)

analyze_strategy_bayes <- function(strat) {
  subset_data <- subset(data, strategy == strat)
  model <- brm(steps_scaled ~ (1|adj_mat) + (1|repl), data = subset_data, 
               family = gaussian(), cores = 4, iter = 2000)
  print(paste("Analysis for strategy:", strat))
  print(summary(model))
  
  # Calculate ICC
  post <- posterior_samples(model)
  icc_adj_mat <- post$sd_adj_mat__Intercept^2 / 
    (post$sd_adj_mat__Intercept^2 + post$sd_repl__Intercept^2 + post$sigma^2)
  icc_repl <- post$sd_repl__Intercept^2 / 
    (post$sd_adj_mat__Intercept^2 + post$sd_repl__Intercept^2 + post$sigma^2)
  
  print(paste("Mean ICC for adj_mat:", mean(icc_adj_mat)))
  print(paste("Mean ICC for repl:", mean(icc_repl)))
  
  cat("\n\n")
}

strategies <- levels(data$strategy)
lapply(strategies, analyze_strategy_bayes)

```

```{r}
# Function to remove isomorphic duplicates

``` 

```{r}
plot_graph_panel <- function(df, num_nodes) {
  # Extract unique adjacency matrices
  unique_adj_matrices <- df %>% 
    distinct(adj_mat, num_nodes)
  
  plot_list <- list()
  
  # Loop through unique adjacency matrices to create graph plots
  for (i in 1:nrow(unique_adj_matrices)) {
    adj_string <- unique_adj_matrices$adj_mat[i]
    num_nodes <- unique_adj_matrices$num_nodes[i]
    
    # Convert the adjacency string to a numeric vector
    adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
    adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
    
    # Create a graph object
    g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
    
    # Assign names to nodes
    V(g)$name <- as.character(1:num_nodes)
    
    # Create the graph plot using ggraph
    graph_plot <- ggraph(g, layout = "tree") +
      geom_edge_link(arrow = arrow(length = unit(2, 'mm'), type = "closed"), end_cap = circle(2, 'mm')) +
      geom_node_point(size = 2) +
      theme_void() +
      theme(
        plot.margin = unit(c(1,1,1,1), "pt"), # Slight margin to separate plots
        panel.border = element_rect(color = "black", fill = NA, size = 0.25) # Thin black border
      )
    
    # Store the plot
    plot_list[[i]] <- graph_plot
  }
  
  # Calculate the number of plots
  n_plots <- length(plot_list)
  
  # Determine the number of columns and rows for the grid layout
  # Adjust n_cols and n_rows according to your preferences
  n_cols <- ceiling(sqrt(n_plots))
  n_rows <- ceiling(n_plots / n_cols)
  
  # Arrange the plots using cowplot's plot_grid function
  combined_plot <- plot_grid(plotlist = plot_list, ncol = n_cols, nrow = n_rows, align = 'none')
  
  # Save the combined plot to a PDF file with specified dimensions
  # Adjust the width and height according to the number of columns and rows
  pdf_width <- n_cols * 1.5  # Each plot is approximately 1.5 inches wide
  pdf_height <- n_rows * 1.5 # Each plot is approximately 1.5 inches tall
  
  # Save to PDF
  ggsave(filename = paste0("./output/all_graphs_", num_nodes, ".pdf"), plot = combined_plot, width = pdf_width, height = pdf_height, units = "in")
  
  # Optional: Print the combined plot to the R graphics device
  # Note: For a large number of plots, this may not display properly in RStudio's plot pane. It's recommended to view the saved PDF.
  print(combined_plot)
}
num_nodes <- 4
data <- read_file(num_nodes)
data <- clean_file(data)
data <- remove_duplicates(data)
plot <- plot_graph_panel(data, num_nodes)
```





