---
title: "YAM analysis"
author: "Nanda Jafarian"
date: "2024-09-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(igraph)
library(combinat)
library(ggplot2)
library(gridExtra)
library(ggraph)
library(dplyr)
library(grid)
library(cowplot)
``` 



```{r}

calc_total_distance_from_root <- function(graph, root="1") {
  all_paths <- list()
  total_distance <- 0
  
  for (node in V(graph)$name) {
    if (node != root) {
      paths <- all_simple_paths(graph, from=root, to=node, mode="out")
      all_paths[[node]] <- paths
      for (path in paths) {
        total_distance <- total_distance + (length(path) - 1)
      }
    }
  }
  return(total_distance)
}

plotRatioByDistance <- function(data, DV, DV_label) { 

  result_df <- data.frame(TotalDistance=numeric(), Ratio=numeric(), alpha=factor(), stringsAsFactors=FALSE)
  
  for (alpha_value in unique(data$alpha)) {
    data_sub <- subset(data, alpha == alpha_value)
    
    unique_combinations <- data_sub %>%
      select(num_nodes, adj_mat) %>%
      distinct()
    
    for (i in seq_len(nrow(unique_combinations))) {
      combination <- unique_combinations[i, ]
      adj_string <- combination$adj_mat
      num_nodes <- combination$num_nodes

      adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
      adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
      g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
      V(g)$name <- as.character(1:num_nodes)
      total_distance <- calc_total_distance_from_root(g, root="1")
      
      strategies_data <- subset(data_sub, adj_mat == adj_string & num_nodes == num_nodes)
      
      if (nrow(strategies_data) > 0) {
        random_learning_steps <- strategies_data[strategies_data$strategy == "RandomLearning", DV]
        payoff_based_steps <- strategies_data[strategies_data$strategy == "PayoffBasedLearning", DV]
        
        if (length(random_learning_steps) > 1 && length(payoff_based_steps) > 1) {
          # Compute trimmed means
          trimmed_mean_random <- mean(random_learning_steps, trim = 0.1)
          trimmed_mean_payoff <- mean(payoff_based_steps, trim = 0.1)
          
          # Calculate the ratio
          ratio <- trimmed_mean_payoff / trimmed_mean_random
          
          # Append to the result dataframe
          result_df <- rbind(result_df, data.frame(TotalDistance=total_distance, Ratio=ratio, alpha=factor(alpha_value)))
        }
      }
    }
  }
  result_df <- result_df[result_df$Ratio < 3,]
  plot <- ggplot(result_df, aes(x = TotalDistance, y = Ratio, color = alpha)) +
    geom_point() +
    geom_hline(yintercept = 1, color = "black", linetype = "dashed") +
    geom_smooth(method = "loess", se = FALSE) +
    labs(title = paste0("Ratio of ", DV_label, " (PayoffBased / RandomLearning) by Distance"),
         subtitle = paste0("Number of Nodes: ", num_nodes),
         x = "Total Distance from Root",
         y = "Ratio") +
    theme_minimal() +
    scale_color_discrete(name = "Alpha") + 
    scale_y_continuous(
      breaks = seq(0, max(result_df$Ratio) + 1, by = 1),
      minor_breaks = seq(0, max(result_df$Ratio), by = 0.5)
      )
  
  print(plot)
  return(plot) 
}

num_nodes <- 6
filename <- paste0("./output/expected_steps_", num_nodes, ".csv.gz")
data <- read.csv(gzfile(filename), stringsAsFactors = FALSE, colClasses = c(adj_mat = "character")) %>%
  filter(!is.nan(step_payoff))

sum(is.nan(data$step_payoff))

steps_plot <- plotRatioByDistance(data[data$alpha >= 0, ], "steps", "Expected Steps")
payoff_plot <- plotRatioByDistance(data[data$alpha >= 0, ], "step_payoff", "Expected Payoff/Step")

``` 


# Plot the expected steps by strategy for each adjacency matrix

```{r}
# Load the data
getwd()
data <- read.csv(gzfile("./output/expected_steps_5.csv.gz"), stringsAsFactors = FALSE, colClasses = c(AdjacencyMatrix = "character"))

# Filter data for Alpha == 1
data_sub <- subset(data, alpha == 1.0)

# Remove isomorphic duplicates
data_sub_unique <- remove_duplicates(data_sub)

plots_list <- list()

unique_combinations <- unique(data_sub_unique[, c("AdjacencyMatrix", "NumNodes")])

# Loop over each unique combination
for (i in seq_len(nrow(unique_combinations))) {
  combination <- unique_combinations[i, ]
  
  adj_string <- combination$adj_mat
  num_nodes <- combination$num_nodes
  
  # Convert the adjacency string to a numeric vector
  adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
  adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
  
  # Create a graph object
  g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
  
  # Assign names to nodes
  V(g)$name <- as.character(1:num_nodes)
  
  # Create the graph plot using ggraph
  graph_plot <- ggraph(g, layout = "tree") +
    geom_edge_link(arrow = arrow(length = unit(4, 'mm'), type = "closed"), end_cap = circle(3, 'mm')) +
    geom_node_point(size = 5) +
    theme_void()
  
  # Get ExpectedSteps for different Strategies for the same AdjacencyMatrix and NumNodes
  strategies_data <- subset(data_sub_unique, adj_mat == adj_string & num_nodes == num_nodes)
  
  # Check if strategies_data is not empty
  if (nrow(strategies_data) > 0) {
    # Prepare data for bar plot
    bar_data <- aggregate(steps ~ strategy, data = strategies_data, FUN = mean)
    
    # Create bar plot
    bar_plot <- ggplot(bar_data, aes(x = strategy, y = steps, fill = strategy)) +
      geom_bar(stat = 'identity') +
      ylim(0, max(bar_data$steps) + 1) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")
    
    # Arrange the graph and bar plot side by side
    combined_plot <- grid.arrange(graph_plot, bar_plot, ncol = 2)
    
    # Store the combined plot
    plots_list[[i]] <- combined_plot
  }
}


for (i in seq_along(plots_list)) {
  grid.newpage()
  grid.draw(plots_list[[i]])
}

## plot 3x3 grid
outplot <- grid.arrange(grobs = plots_list, ncol = 3, top = textGrob("Expected Steps until Absorption for Î± = 1.0 "))

```

```{r}
# Function to remove isomorphic duplicates
remove_duplicates <- function(data) {
  unique_graphs <- list()
  unique_indices <- c()
  
  unique_combinations <- unique(data[, c("AdjacencyMatrix", "NumNodes")])
  
  for (i in seq_len(nrow(unique_combinations))) {
    adj_string <- unique_combinations$AdjacencyMatrix[i]
    num_nodes <- unique_combinations$NumNodes[i]
    
    # Convert the adjacency string to a numeric vector
    adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
    adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
    
    # Create a graph object
    g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
    
    # Check if the graph is isomorphic to any of the already added unique graphs
    is_duplicate <- any(sapply(unique_graphs, function(unique_g) isomorphic(unique_g, g)))
    
    if (!is_duplicate) {
      unique_graphs <- append(unique_graphs, list(g))
      unique_indices <- c(unique_indices, which(data$AdjacencyMatrix == adj_string & data$NumNodes == num_nodes))
    }
  }
  
  return(data[unique_indices, ])
}
``` 

```{r}
plot_graph_panel <- function(df, num_nodes) {
  # Extract unique adjacency matrices
  unique_adj_matrices <- df %>% 
    distinct(adj_mat, num_nodes)
  
  plot_list <- list()
  
  # Loop through unique adjacency matrices to create graph plots
  for (i in 1:nrow(unique_adj_matrices)) {
    adj_string <- unique_adj_matrices$adj_mat[i]
    num_nodes <- unique_adj_matrices$num_nodes[i]
    
    # Convert the adjacency string to a numeric vector
    adjacency_vector <- as.numeric(unlist(strsplit(adj_string, "")))
    adjacency_matrix <- matrix(adjacency_vector, nrow = num_nodes, ncol = num_nodes, byrow = TRUE)
    
    # Create a graph object
    g <- graph_from_adjacency_matrix(adjacency_matrix, mode = "directed")
    
    # Assign names to nodes
    V(g)$name <- as.character(1:num_nodes)
    
    # Create the graph plot using ggraph
    graph_plot <- ggraph(g, layout = "tree") +
      geom_edge_link(arrow = arrow(length = unit(2, 'mm'), type = "closed"), end_cap = circle(2, 'mm')) +
      geom_node_point(size = 2) +
      theme_void() +
      theme(
        plot.margin = unit(c(1,1,1,1), "pt"), # Slight margin to separate plots
        panel.border = element_rect(color = "black", fill = NA, size = 0.25) # Thin black border
      )
    
    # Store the plot
    plot_list[[i]] <- graph_plot
  }
  
  # Calculate the number of plots
  n_plots <- length(plot_list)
  
  # Determine the number of columns and rows for the grid layout
  # Adjust n_cols and n_rows according to your preferences
  n_cols <- ceiling(sqrt(n_plots))
  n_rows <- ceiling(n_plots / n_cols)
  
  # Arrange the plots using cowplot's plot_grid function
  combined_plot <- plot_grid(plotlist = plot_list, ncol = n_cols, nrow = n_rows, align = 'none')
  
  # Save the combined plot to a PDF file with specified dimensions
  # Adjust the width and height according to the number of columns and rows
  pdf_width <- n_cols * 1.5  # Each plot is approximately 1.5 inches wide
  pdf_height <- n_rows * 1.5 # Each plot is approximately 1.5 inches tall
  
  # Save to PDF
  ggsave(filename = paste0("./output/all_graphs_", num_nodes, ".pdf"), plot = combined_plot, width = pdf_width, height = pdf_height, units = "in")
  
  # Optional: Print the combined plot to the R graphics device
  # Note: For a large number of plots, this may not display properly in RStudio's plot pane. It's recommended to view the saved PDF.
  # print(combined_plot)
}


plot <- plot_graph_panel(data, num_nodes)
```

