#ifndef DEBUG_HPP
#define DEBUG_HPP

#include <iostream>


#define DEBUG_LEVEL 2  // Set to 0 to disable debug output, 1 to enable, 2 to also print the full matrices
std::ostream& setPrecision(std::ostream& os, int precision);

#define DEBUG_PRINT(level, x) \
    if (DEBUG_LEVEL >= level) { \
        std::ios_base::fmtflags old_flags = std::cout.flags(); \
        std::streamsize old_prec = std::cout.precision(); \
        std::cout << x << '\n'; \
        std::cout.flags(old_flags); \
        std::cout.precision(old_prec); \
    }


#endif //DEBUG_HPP
#ifndef EXPECTEDSTEPS_HPP
#define EXPECTEDSTEPS_HPP

#include "Types.hpp"
#include "Learning.hpp"

#include <random>
#include <vector>
#include <unordered_map>
#include <tuple>


std::vector<std::vector<double>> computeIMinusQ(
    const std::vector<std::vector<double>>& reorderedTransitionMatrix,
    int numTransientStates
);

std::vector<std::vector<double>> buildTransitionMatrix(
    const std::vector<Repertoire>& repertoiresList,
    const std::unordered_map<Repertoire, int, RepertoireHash>& repertoireIndexMap,
    Strategy strategy,
    const AdjacencyMatrix& adjacencyMatrix,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
);

bool isAbsorbingState(const Repertoire& repertoire);

// Function to reorder the transition matrix, separating transient and absorbing states
std::tuple<std::vector<std::vector<double>>, std::unordered_map<int, int>, int> reorderTransitionMatrix(
    const std::vector<std::vector<double>>& transitionMatrix,
    const std::vector<std::pair<Repertoire, int>>& repertoiresWithIndices,
    const std::unordered_map<Repertoire, int, RepertoireHash>& repertoireIndexMap,
    Trait rootNode
);

// Ccompute expected steps from the (I - Q) matrix
double computeExpectedStepsFromMatrix(
    const std::vector<std::vector<double>>& iMinusQ,
    int initialStateNewIndex
);

// Compute expected payoffs from the (I - Q) matrix and payoff vector
std::vector<double> computeExpectedPayoffs(
    const std::vector<std::vector<double>>& iMinusQ,
    const std::vector<double>& payoffVector
);

// Compute learning success probability
double computeExpectedTransitionsPerStep(
    const std::vector<std::vector<double>>& fundamentalMatrix,
    const std::vector<std::vector<double>>& reorderedTransitionMatrix,
    int initialStateNewIndex,
    int numTransientStates,
    double expectedSteps
);

// Main function
bool computeExpectedSteps(
    const AdjacencyMatrix& adjacencyMatrix,
    Strategy strategy,
    double alpha,
    std::mt19937& gen,
    double& expectedSteps,                             // Output parameter for expected steps
    double& expectedPayoffPerStep,                     // Output parameter for expected payoff per step
    double& expectedTransitionsPerStep,                // Output parameter for expected transitions per step
    std::vector<std::vector<double>>& transitionMatrix // Output parameter for the transition matrix
);

#endif // EXPECTEDSTEPS_HPP
#ifndef GRAPH_HPP 
#define GRAPH_HPP

#include "Types.hpp" 

std::vector<int> computeDistances(const AdjacencyMatrix& adjMatrix, Trait root);

std::vector<Trait> parentTraits(const AdjacencyMatrix& adjMatrix, Trait trait);

#endif // GRAPH_HPP#ifndef LEARNING_HPP
#define LEARNING_HPP

#include "Types.hpp"
#include <vector>
#include <string>
#include <random>

std::vector<bool> learnability(const Repertoire& repertoire, const AdjacencyMatrix& adjMatrix);

std::vector<double> baseWeights(
    Strategy strategy,
    const Repertoire& repertoire,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates 
);

std::vector<double> normalizedWeights(
    Strategy strategy,
    const Repertoire& repertoire,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
);

// In this version, trait frequency is the probability that a trait is considered for learning
std::vector<double> normalizedWeights(Strategy strategy, const Repertoire& repertoire, const PayoffVector& payoffs, const std::vector<double>& traitFrequencies, std::mt19937& gen);

Repertoire learnTrait(const Repertoire& repertoire, Trait trait);

std::vector<std::pair<Repertoire, double>> transitionFromState(
    Strategy strategy, 
    const Repertoire& repertoire, 
    const AdjacencyMatrix& adjMatrix, 
    const PayoffVector& payoffs, 
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
);

double stayProbability(std::vector<std::pair<Repertoire, double>> transitions);

struct RepertoireHash {
    std::size_t operator()(const Repertoire& repertoire) const {
        return std::hash<std::string>{}(std::string(repertoire.begin(), repertoire.end()));
    }
};

std::vector<Repertoire> generateReachableRepertoires(
    Strategy strategy, 
    const AdjacencyMatrix& adjMatrix, 
    const PayoffVector& payoffs, 
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
);

std::vector<Repertoire> generateAllRepertoires(const AdjacencyMatrix& adjMatrix);

size_t countLearnedTraits(const Repertoire& r);

std::vector<Repertoire> retrieveBetterRepertoires(const std::vector<Repertoire>& repertoires, const Repertoire& singleRepertoire);

#endif // LEARNING_HPP#ifndef LINEAR_ALGEBRA_HPP
#define LINEAR_ALGEBRA_HPP

#include <vector>

std::vector<double> solveLinearSystem(const std::vector<std::vector<double>>& A, const std::vector<double>& b);

#endif // LINEAR_ALGEBRA_HPP#ifndef PAYOFFS_HPP
#define PAYOFFS_HPP

#include "Types.hpp"
#include <vector>
#include <random>

PayoffVector generatePayoffs(const std::vector<int>& distances, double alpha, std::mt19937& gen);

#endif // PAYOFFS_HPP#ifndef TYPES_HPP 
#define TYPES_HPP

#include <vector>
#include <string>

using Trait = size_t;
using Repertoire = std::vector<bool>;
using PayoffVector = std::vector<double>;
using AdjacencyMatrix = std::vector<std::vector<bool>>;

enum Strategy {
    RandomLearning,
    PayoffBasedLearning,
    VygotskianLearning
};

struct ParamCombination {
    AdjacencyMatrix adjMatrix;
    std::string adjMatrixBinary;
    Strategy strategy;
    double alpha;
    int repl;
};

struct Result {
    int n;
    std::string adjMatrixBinary;
    double alpha;
    Strategy strategy;
    int repl;
    double expectedSteps;
    double expectedPayoffPerStep;
    double expectedTransitionsPerStep;
};

#endif // TYPES_HPP

#ifndef UTILS_HPP
#define UTILS_HPP

#include <vector>
#include <string> 
#include "Types.hpp"

void writeMatrixToCSV(const std::string& filename, const std::vector<std::vector<double>>& matrix);

std::string strategyToString(Strategy strategy);

std::string formatResults(int n, const std::string& adjMatrixBinary, double alpha, Strategy strategy, int repl, double expectedSteps, double expectedPayoffPerStep, double expectedTransitionsPerStep);

std::vector<AdjacencyMatrix> readAdjacencyMatrices(int n);

AdjacencyMatrix binaryStringToAdjacencyMatrix(int n, const std::string& str);

bool charToBool(char c);

void printMatrix(const std::vector<std::vector<double>>& matrix);

int parseArgs(int argc, char* argv[], bool& saveTransitionMatrices);

void writeAndCompressCSV(const std::string& outputDir, int n, const std::vector<std::string>& csvData);

std::string adjMatrixToBinaryString(const AdjacencyMatrix& adjMatrix);

std::vector<ParamCombination> makeCombinations(std::vector<AdjacencyMatrix>& adjacencyMatrices, std::vector<Strategy>& strategies, std::vector<double>& alphas, int replications);

#endif // UTILS_HPP#include "Debug.hpp"

std::ostream& setPrecision(std::ostream& os, int precision) {
    os.setf(std::ios::fixed);
    os.precision(precision);
    return os;
}#include "ExpectedSteps.hpp"

#include "Debug.hpp"
#include "Learning.hpp"
#include "Graph.hpp"
#include "Payoffs.hpp"
#include "LinAlg.hpp"
#include "Utils.hpp"

#include <algorithm>
#include <iostream>
#include <stdexcept>
#include <unordered_map>
#include <numeric>


// Helper function to extract Q matrix and compute (I - Q)
std::vector<std::vector<double>> computeIMinusQ(
    const std::vector<std::vector<double>>& reorderedTransitionMatrix,
    int numTransientStates
) {
    // Extract the Q matrix from the reordered transition matrix. The Q matrix represents the transition probabilities between transient states.
    std::vector<std::vector<double>> qMatrix(numTransientStates, std::vector<double>(numTransientStates));
    for (int i = 0; i < numTransientStates; ++i) {
        for (int j = 0; j < numTransientStates; ++j) {
            qMatrix[i][j] = reorderedTransitionMatrix[i][j];
        }
    }

    DEBUG_PRINT(2, "Q matrix:");
    if(DEBUG_LEVEL >= 2) printMatrix(qMatrix);

    // Subtract the Q matrix from the identity matrix to get I - Q.
    std::vector<std::vector<double>> iMinusQ(numTransientStates, std::vector<double>(numTransientStates));
    for (int i = 0; i < numTransientStates; ++i) {
        for (int j = 0; j < numTransientStates; ++j) {
            iMinusQ[i][j] = (i == j ? 1.0 : 0.0) - qMatrix[i][j];
        }
    }

    DEBUG_PRINT(2, "I - Q matrix:");
    if(DEBUG_LEVEL >= 2) printMatrix(iMinusQ);

    return iMinusQ;
}

std::vector<std::vector<double>> buildTransitionMatrix(
    const std::vector<Repertoire>& repertoiresList,
    const std::unordered_map<Repertoire, int, RepertoireHash>& repertoireIndexMap,
    Strategy strategy,
    const AdjacencyMatrix& adjacencyMatrix,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
) {
    int numStates = static_cast<int>(repertoiresList.size());
    std::vector<std::vector<double>> transitionMatrix(numStates, std::vector<double>(numStates, 0.0));

    for (int i = 0; i < numStates; ++i) {
        const Repertoire& repertoire = repertoiresList[i];
        auto transitions = transitionFromState(strategy, repertoire, adjacencyMatrix, payoffs, traitFrequencies, allStates);
        auto stayProb = stayProbability(transitions);

        std::unordered_map<int, double> probMap;
        probMap[i] = stayProb;

        for (const auto& [nextRepertoire, prob] : transitions) {
            int nextIndex = repertoireIndexMap.at(nextRepertoire);
            probMap[nextIndex] += prob;
        }

        std::vector<double> row(numStates, 0.0);
        for (const auto& [idx, prob] : probMap) {
            row[idx] = prob;
        }
        transitionMatrix[i] = row;
    }

    return transitionMatrix;
}

bool isAbsorbingState(const Repertoire& repertoire) {
    return std::all_of(repertoire.begin(), repertoire.end(), [](bool learned) { return learned; });
}

std::tuple<std::vector<std::vector<double>>, std::unordered_map<int, int>, int> reorderTransitionMatrix(
    const std::vector<std::vector<double>>& transitionMatrix,
    const std::vector<std::pair<Repertoire, int>>& repertoiresWithIndices,
    const std::unordered_map<Repertoire, int, RepertoireHash>& repertoireIndexMap,
    Trait rootNode
) {

    // Build a vector of repertoires indexed by state indices
    size_t numStates = transitionMatrix.size();
    std::vector<Repertoire> repertoires(numStates);
    for (const auto& [repertoire, index] : repertoiresWithIndices) {
        repertoires[index] = repertoire;
    }

    // Create a vector of state indices and initialize with 0, 1, ..., numStates - 1
    std::vector<int> reorderedStateIndices(numStates);
    std::iota(reorderedStateIndices.begin(), reorderedStateIndices.end(), 0);

    // Use std::stable_partition to reorder indices: transient states first, then absorbing states
    auto partitionPoint = std::stable_partition(
        reorderedStateIndices.begin(), reorderedStateIndices.end(),
        [&](int index) { return !isAbsorbingState(repertoires[index]); }
    );

    // Calculate the number of transient states
    int numTransientStates = std::distance(reorderedStateIndices.begin(), partitionPoint);

    // Create a mapping from old indices to new indices
    std::unordered_map<int, int> oldToNewIndexMap;
    for (int newIndex = 0; newIndex < static_cast<int>(reorderedStateIndices.size()); ++newIndex) {
        int oldIndex = reorderedStateIndices[newIndex];
        oldToNewIndexMap[oldIndex] = newIndex;
    }

    // Reorder the transition matrix rows and columns
    std::vector<std::vector<double>> reorderedTransitionMatrix;
    reorderedTransitionMatrix.reserve(numStates);

    for (int oldRowIndex : reorderedStateIndices) {
        const auto& oldRow = transitionMatrix[oldRowIndex];
        std::vector<double> newRow;
        newRow.reserve(numStates);
        for (int oldColumnIndex : reorderedStateIndices) {
            newRow.push_back(oldRow[oldColumnIndex]);
        }
        reorderedTransitionMatrix.push_back(std::move(newRow));
    }

    // Identify the initial state index and map it to the new index
    int n = static_cast<int>(repertoiresWithIndices[0].first.size());
    Repertoire initialRepertoire(n, false);
    initialRepertoire[rootNode] = true;

    auto it = repertoireIndexMap.find(initialRepertoire);
    if (it == repertoireIndexMap.end()) {
        throw std::runtime_error("Initial repertoire not found in repertoire index map.");
    }
    int initialStateIndex = it->second;
    int initialStateNewIndex = oldToNewIndexMap.at(initialStateIndex);

    DEBUG_PRINT(1, "Number of transient states: " << numTransientStates);
    DEBUG_PRINT(1, "Number of absorbing states: " << (numStates - numTransientStates));
    DEBUG_PRINT(1, "Initial state new index: " << initialStateNewIndex);

    return {reorderedTransitionMatrix, oldToNewIndexMap, numTransientStates};
}

std::vector<double> computeExpectedPayoffs(const std::vector<std::vector<double>>& iMinusQ, const std::vector<double>& payoffVector) {
    // Solve the system (I - Q) * expectedPayoffs = payoffVector
    std::vector<double> expectedPayoffs;
    expectedPayoffs = solveLinearSystem(iMinusQ, payoffVector);
    if (std::any_of(expectedPayoffs.begin(), expectedPayoffs.end(), [](double val) { return std::isnan(val) || std::isinf(val); })) {
        DEBUG_PRINT(1, "NaN or Inf found in expectedPayoffs");
    }
    return expectedPayoffs;
}

double computeExpectedStepsFromMatrix(const std::vector<std::vector<double>>& iMinusQ, int initialStateNewIndex) {
    // Set up the b vector (ones)
    int numTransientStates = static_cast<int>(iMinusQ.size());
    std::vector<double> bVector(numTransientStates, 1.0);

    // Solve the system (I - Q) * t = b
    std::vector<double> tSolution = solveLinearSystem(iMinusQ, bVector);
    
    if (std::any_of(tSolution.begin(), tSolution.end(), [](double val) { return std::isnan(val) || std::isinf(val); })) {
        DEBUG_PRINT(1, "NaN or Inf found in tSolution");
    }

    double expectedSteps = tSolution[initialStateNewIndex];
    DEBUG_PRINT(1, "Expected steps:");
    if(DEBUG_LEVEL >= 1) std::cout << "Expected steps: " << expectedSteps << '\n';
    return expectedSteps;
}

void adjustTraitFrequencies(std::vector<double>& traitFrequencies, double adjustmentFactor) {
    // Adjust the frequencies slightly to avoid singularity
    size_t n = traitFrequencies.size();
    for (size_t j = 1; j < n; ++j) {  // Exclude trait 0
        traitFrequencies[j] *= adjustmentFactor;  // Reduce frequencies
    }
    // Ensure frequencies are not zero and normalize
    double sum = std::accumulate(traitFrequencies.begin() + 1, traitFrequencies.end(), 0.0);
    if (sum == 0.0) {
        // If all frequencies become zero, reset to equal distribution
        for (size_t j = 1; j < n; ++j) {
            traitFrequencies[j] = 1.0;
        }
        sum = n - 1.0;
    }
    for (size_t j = 1; j < n; ++j) {
        traitFrequencies[j] /= sum;
    }
}

double computeExpectedTransitionsPerStep(
    const std::vector<std::vector<double>>& fundamentalMatrix,
    const std::vector<std::vector<double>>& reorderedTransitionMatrix,
    int initialStateNewIndex,
    int numTransientStates,
    double expectedSteps
) {
    // Check for division by zero
    if (expectedSteps == 0.0) {
        return 0.0;
    }

    // Compute occupancy probabilities for transient states
    std::vector<double> occupancy_probs(numTransientStates);
    const std::vector<double>& occupancy_counts = fundamentalMatrix[initialStateNewIndex];

    for (int i = 0; i < numTransientStates; ++i) {
        occupancy_probs[i] = occupancy_counts[i] / expectedSteps;
    }

    // Extract self-transition probabilities from the diagonal of Q
    std::vector<double> selfTransitionProbs(numTransientStates);
    for (int i = 0; i < numTransientStates; ++i) {
        selfTransitionProbs[i] = reorderedTransitionMatrix[i][i];
    }

    // Compute expected self-transition probability
    double expectedSelfTransitionProb = 0.0;
    for (int i = 0; i < numTransientStates; ++i) {
        expectedSelfTransitionProb += occupancy_probs[i] * selfTransitionProbs[i];
    }

    // Expected number of transitions per step
    double expectedTransitionsPerStep = 1.0 - expectedSelfTransitionProb;

    return expectedTransitionsPerStep;
}

bool computeExpectedSteps(
    const AdjacencyMatrix& adjacencyMatrix,
    Strategy strategy,
    double alpha,
    std::mt19937& gen,
    double& expectedSteps,                             
    double& expectedPayoffPerStep,
    double& expectedTransitionsPerStep,                     
    std::vector<std::vector<double>>& transitionMatrix 
) {
    try {
        Trait rootNode = 0;
        std::vector<int> distances = computeDistances(adjacencyMatrix, rootNode);
        PayoffVector payoffs = generatePayoffs(distances, alpha, gen);
        // print payoffs
        DEBUG_PRINT(2, "Payoffs:");
        if(DEBUG_LEVEL >= 2) {
            for (size_t i = 0; i < payoffs.size(); ++i) {
                std::cout << "Trait " << i << ": " << payoffs[i] << '\n';
            }
        }
        size_t n = adjacencyMatrix.size();
        std::vector<double> traitFrequencies(n, 1.0);
        traitFrequencies[0] = 1.0;

        const int MAX_ITERATIONS = 100;
        const double EPSILON = 1e-4;
        int iteration = 0;
        double maxDifference;

        DEBUG_PRINT(1, "Starting iterative fixed-point method for trait frequencies");

        auto allStates = generateAllRepertoires(adjacencyMatrix);
        do {
            DEBUG_PRINT(1, "Iteration " << iteration + 1);

            std::vector<double> prevFrequencies = traitFrequencies;
            bool success = false;
            int adjustmentAttempts = 0;
            const int MAX_ADJUSTMENT_ATTEMPTS = 10;
            double adjustmentFactor = 0.95;

            while (!success && adjustmentAttempts < MAX_ADJUSTMENT_ATTEMPTS) {
                try {
                    std::vector<Repertoire> repertoiresList = generateReachableRepertoires(strategy, adjacencyMatrix, payoffs, traitFrequencies, allStates);
                    std::vector<std::pair<Repertoire, int>> repertoiresWithIndices;

                    for (size_t i = 0; i < repertoiresList.size(); ++i) {
                        repertoiresWithIndices.emplace_back(repertoiresList[i], static_cast<int>(i));
                    }

                    std::unordered_map<Repertoire, int, RepertoireHash> repertoireIndexMap;
                    for (const auto& [repertoire, index] : repertoiresWithIndices) {
                        repertoireIndexMap[repertoire] = index;
                    }

                    transitionMatrix = buildTransitionMatrix(repertoiresList, repertoireIndexMap, strategy, adjacencyMatrix, payoffs, traitFrequencies, allStates);
                    auto [reorderedTransitionMatrix, oldToNewIndexMap, numTransientStates] = reorderTransitionMatrix(transitionMatrix, repertoiresWithIndices, repertoireIndexMap, rootNode);

                    DEBUG_PRINT(2, "Reordered transition matrix:");
                    if(DEBUG_LEVEL >= 2) printMatrix(reorderedTransitionMatrix);
                    if (numTransientStates == 0) {
                        expectedSteps = 0.0;
                        expectedPayoffPerStep = std::accumulate(payoffs.begin(), payoffs.end(), 0.0);
                        return true;
                    }

                    std::vector<std::vector<double>> iMinusQ = computeIMinusQ(reorderedTransitionMatrix, numTransientStates);
                    std::vector<std::vector<double>> fundamentalMatrix(numTransientStates, std::vector<double>(numTransientStates));

                    for (int i = 0; i < numTransientStates; ++i) {
                        std::vector<double> e_i(numTransientStates, 0.0);
                        e_i[i] = 1.0;
                        std::vector<double> column = solveLinearSystem(iMinusQ, e_i);

                        for (int j = 0; j < numTransientStates; ++j) {
                            fundamentalMatrix[j][i] = column[j];
                        }
                    }

                    double totalTransientTime = 0.0;
                    for (const auto& row : fundamentalMatrix) {
                        totalTransientTime += std::accumulate(row.begin(), row.end(), 0.0);
                    }
                    
                    //For each trait, loop through all repertoire states. 
                    //Use the fundamental matrix to get the expected time spent in each transient state.
                    //Time spent in transient states contributes to the trait frequency for all traits in that state.  
                    for (size_t j = 1; j < n; ++j) {
                        double timeTraitKnown = 0.0;
                        for (size_t r = 0; r < repertoiresList.size(); ++r) {
                            if (repertoiresList[r][j]) {
                                int newIndex = oldToNewIndexMap[r];
                                if (newIndex < numTransientStates) {
                                    timeTraitKnown += fundamentalMatrix[0][newIndex];
                                }
                            }
                        }
                        traitFrequencies[j] = timeTraitKnown / totalTransientTime;
                    }

                    // Normalize trait frequencies
                    double sum = std::accumulate(traitFrequencies.begin() + 1, traitFrequencies.end(), 0.0);
                    for (size_t j = 1; j < n; ++j) {
                        traitFrequencies[j] /= sum;
                    }

                    success = true;
                } catch (const std::runtime_error& e) {
                    ++adjustmentAttempts;
                    adjustTraitFrequencies(traitFrequencies, adjustmentFactor);
                    DEBUG_PRINT(1, "Singular matrix encountered, adjusting trait frequencies");
                }
            }

            if (!success) {
                throw std::runtime_error("Unable to compute expected steps due to singular matrix, even after adjustments");
            }

            maxDifference = 0.0;
            for (size_t j = 1; j < n; ++j) {
                maxDifference = std::max(maxDifference, std::abs(traitFrequencies[j] - prevFrequencies[j]));
            }

            DEBUG_PRINT(1, "Current trait frequencies:");
            if (DEBUG_LEVEL >= 1) {
                for (size_t j = 0; j < n; ++j) {
                    std::cout << "Trait " << j << ": " << traitFrequencies[j] << '\n';
                }
            }
            DEBUG_PRINT(1, "Max difference: " << maxDifference);

            iteration++;
        } while (maxDifference > EPSILON && iteration < MAX_ITERATIONS);

        if (iteration == MAX_ITERATIONS) {
            DEBUG_PRINT(1, "Warning: Maximum iterations reached without convergence");
        } else {
            DEBUG_PRINT(1, "Converged after " << iteration << " iterations");
        }

        std::vector<Repertoire> finalRepertoiresList = generateReachableRepertoires(strategy, adjacencyMatrix, payoffs, traitFrequencies, allStates);
        std::unordered_map<Repertoire, int, RepertoireHash> finalRepertoireIndexMap;

        for (size_t i = 0; i < finalRepertoiresList.size(); ++i) {
            finalRepertoireIndexMap[finalRepertoiresList[i]] = static_cast<int>(i);
        }

        std::vector<std::pair<Repertoire, int>> finalRepertoiresWithIndices;
        for (size_t i = 0; i < finalRepertoiresList.size(); ++i) {
            finalRepertoiresWithIndices.emplace_back(finalRepertoiresList[i], static_cast<int>(i));
        }

        transitionMatrix = buildTransitionMatrix(finalRepertoiresList, finalRepertoireIndexMap, strategy, adjacencyMatrix, payoffs, traitFrequencies, allStates);

        auto [finalReorderedTransitionMatrix, finalOldToNewIndexMap, finalNumTransientStates] = reorderTransitionMatrix(
            transitionMatrix, finalRepertoiresWithIndices, finalRepertoireIndexMap, rootNode
        );

        if (finalNumTransientStates == 0) {
            expectedSteps = 0.0;
            expectedPayoffPerStep = std::accumulate(payoffs.begin(), payoffs.end(), 0.0);
            return true;
        }

        std::vector<std::vector<double>> finalIMinusQ = computeIMinusQ(finalReorderedTransitionMatrix, finalNumTransientStates);
        
        int initialStateIndex = finalRepertoireIndexMap[Repertoire(n, false)];
        Repertoire initialRepertoire(n, false);
        initialRepertoire[rootNode] = true;
        initialStateIndex = finalRepertoireIndexMap[initialRepertoire];
        int initialStateNewIndex = finalOldToNewIndexMap[initialStateIndex];

        expectedSteps = computeExpectedStepsFromMatrix(finalIMinusQ, initialStateNewIndex);

        //Recompute fundamental matrix for expected transitions per step
        std::vector<std::vector<double>> fundamentalMatrix(finalNumTransientStates, std::vector<double>(finalNumTransientStates));

        for (int i = 0; i < finalNumTransientStates; ++i) {
            std::vector<double> e_i(finalNumTransientStates, 0.0);
            e_i[i] = 1.0;
            std::vector<double> column = solveLinearSystem(finalIMinusQ, e_i);

            for (int j = 0; j < finalNumTransientStates; ++j) {
                fundamentalMatrix[j][i] = column[j];
            }
        }

        expectedTransitionsPerStep = computeExpectedTransitionsPerStep(fundamentalMatrix, finalReorderedTransitionMatrix, initialStateNewIndex, finalNumTransientStates, expectedSteps);

        std::vector<double> statePayoffs(finalRepertoiresList.size(), 0.0);
        for (size_t i = 0; i < finalRepertoiresList.size(); ++i) {
            const auto& repertoire = finalRepertoiresList[i];
            for (size_t j = 0; j < repertoire.size(); ++j) {
                if (repertoire[j]) {
                    statePayoffs[i] += payoffs[j];
                }
            }
        }

        std::vector<double> reorderedStatePayoffs(statePayoffs.size());
        for (size_t i = 0; i < statePayoffs.size(); ++i) {
            reorderedStatePayoffs[finalOldToNewIndexMap[i]] = statePayoffs[i];
        }

        std::vector<double> payoffVector(finalNumTransientStates);
        for (int i = 0; i < finalNumTransientStates; ++i) {
            payoffVector[i] = reorderedStatePayoffs[i];
        }

        std::vector<double> expectedPayoffs = computeExpectedPayoffs(finalIMinusQ, payoffVector);
        double totalExpectedPayoff = expectedPayoffs[initialStateNewIndex];
        expectedPayoffPerStep = totalExpectedPayoff / expectedSteps;

        return true;

    } catch (const std::exception& e) {
        // On encountering an exception, return false
        return false;
    }
}#include "Graph.hpp"

#include <cstddef>
#include <stdexcept>
#include <queue>

std::vector<int> computeDistances(const AdjacencyMatrix& adjMatrix, Trait root) {
    size_t n = adjMatrix.size();
    std::vector<int> distances(n, -1);
    std::queue<Trait> q;

    distances[root] = 0;
    q.push(root);

    while (!q.empty()) {
        Trait current = q.front();
        q.pop();

        for (size_t neighbor = 0; neighbor < n; ++neighbor) {
            if (adjMatrix[current][neighbor] && distances[neighbor] == -1) {
                distances[neighbor] = distances[current] + 1;
                q.push(neighbor);
            }
        }
    }

    for (size_t node = 0; node < n; ++node) {
        if (distances[node] == -1) {
            throw std::runtime_error("Graph is not connected");
        }
    }
    return distances;
}

std::vector<Trait> parentTraits(const AdjacencyMatrix& adjMatrix, Trait trait) {
    std::vector<Trait> parents;
    size_t n = adjMatrix.size();

    for (size_t i = 0; i < n; ++i) {
        if (adjMatrix[i][trait]) {
            parents.push_back(i);
        }
    }
    return parents;
}

#include "Learning.hpp"
#include "Graph.hpp"
#include <numeric>
#include <stdexcept>
#include <algorithm>
#include <queue>
#include <unordered_set>

std::vector<bool> learnability(const Repertoire& repertoire, const AdjacencyMatrix& adjMatrix) {
    std::vector<bool> learnable(repertoire.size());

    for (size_t trait = 0; trait < repertoire.size(); ++trait) {
        auto parents = parentTraits(adjMatrix, trait);

        // true if all parents are in the repertoire
        bool parent_product = std::accumulate(parents.begin(), parents.end(), true,
            [&repertoire](bool acc, Trait parent) {
                return acc && repertoire[parent];
            });

        // true if the trait is not in the repertoire and all parents are in the repertoire
        bool is_learnable = !repertoire[trait] && parent_product;

        learnable[trait] = is_learnable;
    }
    return learnable;
}

double computeDelta(const Repertoire& r, const Repertoire& s) {
    // count the number of traits that are present in target state s but not in current state r
    return std::inner_product(s.begin(), s.end(), r.begin(), 0.0,
        std::plus<>(), [](bool s_i, bool r_i) { return (s_i && !r_i) ? 1 : 0; });
}

double phi(double delta) {
    return std::pow(2.0, 1.0 - delta);
}

std::vector<double> vygotskianBaseWeights(
    const Repertoire& repertoire,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
) {
    std::vector<double> w_star(repertoire.size(), 0.0);
    std::vector<double> stateWeights(allStates.size(), 0.0);

    // Compute state weights
    for (size_t i = 0; i < allStates.size(); ++i) {
        double delta = computeDelta(repertoire, allStates[i]);
        if (delta > 0) {  // Only consider states with at least one more trait
            stateWeights[i] = traitFrequencies[i] * phi(delta);
        }
    }

    // Compute trait contributions
    for (size_t j = 0; j < repertoire.size(); ++j) {
        if (!repertoire[j]) {  // Only consider unlearned traits
            for (size_t i = 0; i < allStates.size(); ++i) {
                if (allStates[i][j] && computeDelta(repertoire, allStates[i]) > 0) {
                    int N_s = computeDelta(repertoire, allStates[i]);  // Number of additional traits known in s but not in r
                    w_star[j] += stateWeights[i] / N_s;
                }
            }
        }
    }

    return w_star;
}

std::vector<double> baseWeights(
    Strategy strategy,
    const Repertoire& repertoire,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates  
) {
    switch (strategy) {
    case RandomLearning:
        return traitFrequencies;
    case PayoffBasedLearning:
        {
            std::vector<double> result(payoffs.size());
            std::transform(payoffs.begin(), payoffs.end(), traitFrequencies.begin(), result.begin(), std::multiplies<>());
            return result;
        }
    case VygotskianLearning:
        return vygotskianBaseWeights(repertoire, traitFrequencies, allStates);
    default:
        throw std::runtime_error("Unknown strategy");
    }
}


std::vector<double> normalizedWeights(
    Strategy strategy,
    const Repertoire& repertoire,
    const PayoffVector& payoffs,
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
)  {
    std::vector<double> w_star = baseWeights(strategy, repertoire, payoffs, traitFrequencies, allStates);

    std::vector<double> w_unlearned(repertoire.size());
    for (Trait trait = 0; trait < repertoire.size(); ++trait) {
        w_unlearned[trait] = repertoire[trait] ? 0.0 : w_star[trait];
    }

    double total = std::accumulate(w_unlearned.begin(), w_unlearned.end(), 0.0);

    if (total == 0.0) {
        return std::vector<double>(repertoire.size(), 0.0);
    }

    std::transform(w_unlearned.begin(), w_unlearned.end(), w_unlearned.begin(),
        [total](double w) { return w / total; });

    return w_unlearned;
}



Repertoire learnTrait(const Repertoire& repertoire, Trait trait) {
    Repertoire newRepertoire = repertoire;
    newRepertoire[trait] = true;
    return newRepertoire;
}

std::vector<std::pair<Repertoire, double>> transitionFromState(
    Strategy strategy,
    const Repertoire& repertoire, 
    const AdjacencyMatrix& adjMatrix, 
    const PayoffVector& payoffs, 
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
) {

    std::vector<Repertoire> newStates = retrieveBetterRepertoires(allStates, repertoire);
    std::vector<double> w = normalizedWeights(strategy, repertoire, payoffs, traitFrequencies, newStates);
    std::vector<bool> learnable = learnability(repertoire, adjMatrix);

    std::vector<std::pair<Repertoire, double>> transitions;

    for(Trait trait = 0; trait < repertoire.size(); ++trait) {
        if (learnable[trait] && w[trait] > 0.0) {
            transitions.emplace_back(learnTrait(repertoire, trait), w[trait]);
        }
    }

    return transitions;
}

double stayProbability(std::vector<std::pair<Repertoire, double>> transitions) {

    double totalTransitionProbability = std::accumulate(
        transitions.begin(), transitions.end(), 0.0,
        [](double sum, const auto& transition) { 
            return sum + transition.second;
        }
    );

    return 1.0 - totalTransitionProbability;
}

std::vector<Repertoire> generateReachableRepertoires(
    Strategy strategy, 
    const AdjacencyMatrix& adjMatrix, 
    const PayoffVector& payoffs, 
    const std::vector<double>& traitFrequencies,
    const std::vector<Repertoire>& allStates
) {
    size_t n = adjMatrix.size();
    Repertoire initialRepertoire(n, false);
    initialRepertoire[0] = true; // root trait is always learned

    std::queue<Repertoire> queue;
    std::unordered_set<Repertoire, RepertoireHash> visited;
    std::vector<Repertoire> result;

    queue.push(initialRepertoire);

    while (!queue.empty()) {
        Repertoire r = queue.front();
        queue.pop();

        if (visited.find(r) == visited.end()) {
            visited.insert(r);
            result.push_back(r);

            auto transitions = transitionFromState(strategy, r, adjMatrix, payoffs, traitFrequencies, allStates);
            for (const auto& transition : transitions) {
                const Repertoire& r_prime = transition.first;
                if (visited.find(r_prime) == visited.end()) {
                    queue.push(r_prime);
                }
            }
        }
    }

    return result;
}

std::vector<Repertoire> generateAllRepertoires(const AdjacencyMatrix& adjMatrix) {
    size_t n = adjMatrix.size();
    Repertoire initialRepertoire(n, false);
    initialRepertoire[0] = true; // root trait is always learned

    std::queue<Repertoire> queue;
    std::unordered_set<Repertoire, RepertoireHash> visited;
    std::vector<Repertoire> result;

    queue.push(initialRepertoire);

    while (!queue.empty()) {
        Repertoire r = queue.front();
        queue.pop();

        if (visited.find(r) == visited.end()) {
            visited.insert(r);
            result.push_back(r);

            std::vector<bool> learnable = learnability(r, adjMatrix);
            for (Trait trait = 0; trait < n; ++trait) {
                if (learnable[trait]) {
                    Repertoire r_new = learnTrait(r, trait);
                    if (visited.find(r_new) == visited.end()) {
                        queue.push(r_new);
                    }
                }
            }
        }
    }

    return result;
}

size_t countLearnedTraits(const Repertoire& r) {
    return std::count(r.begin(), r.end(), true);
}

std::vector<Repertoire> retrieveBetterRepertoires(const std::vector<Repertoire>& repertoires, const Repertoire& singleRepertoire) {
    std::vector<Repertoire> result;
    size_t singleRepertoireLearnedTraits = countLearnedTraits(singleRepertoire);

    for (const Repertoire& r : repertoires) {
        if (countLearnedTraits(r) > singleRepertoireLearnedTraits) {
            result.push_back(r);
        }
    }

    return result;
}#include "LinAlg.hpp"
#include <cmath>
#include <algorithm>
#include <stdexcept>

const double EPSILON = 1e-10;

std::vector<double> solveLinearSystem(const std::vector<std::vector<double>>& a, const std::vector<double>& b) {
    int n = a.size();
    std::vector<std::vector<double>> LU = a;
    std::vector<int> P(n);
    for (int i = 0; i < n; i++) P[i] = i;

    // Perform LU decomposition with partial pivoting
    for (int k = 0; k < n - 1; k++) {
        // Find the pivot row
        int pivot_row = k;
        double pivot_val = std::abs(LU[k][k]);
        for (int i = k + 1; i < n; i++) {
            if (std::abs(LU[i][k]) > pivot_val) {
                pivot_row = i;
                pivot_val = std::abs(LU[i][k]);
            }
        }

        // If the pivot value is too small, the matrix is singular or nearly singular
        if (pivot_val < EPSILON) {
            throw std::runtime_error("Matrix is singular or nearly singular");
        }

        // Swap the current row with the pivot row
        if (pivot_row != k) {
            std::swap(LU[k], LU[pivot_row]);
            std::swap(P[k], P[pivot_row]);
        }

        // Perform the elimination process to form the LU decomposition
        for (int i = k + 1; i < n; i++) {
            LU[i][k] /= LU[k][k];
            for (int j = k + 1; j < n; j++) {
                LU[i][j] -= LU[i][k] * LU[k][j];
            }
        }
    }

    // Forward substitution to solve Ly = Pb
    std::vector<double> y(n);
    for (int i = 0; i < n; i++) {
        y[i] = b[P[i]];
        for (int j = 0; j < i; j++) {
            y[i] -= LU[i][j] * y[j];
        }
    }

    // Backward substitution to solve Ux = y
    std::vector<double> x(n);
    for (int i = n - 1; i >= 0; i--) {
        x[i] = y[i];
        for (int j = i + 1; j < n; j++) {
            x[i] -= LU[i][j] * x[j];
        }
        x[i] /= LU[i][i];
    }

    return x;
}#include <iostream>
#include <algorithm>
#include <execution>
#include <vector>
#include <string>
#include <sstream>
#include <filesystem>
#include <random>
#include <iomanip>

#include "Debug.hpp"
#include "Utils.hpp"
#include "Types.hpp"
#include "ExpectedSteps.hpp"

void processRepl(
    int repl,
    const AdjacencyMatrix& adjMatrix,
    const Strategy& strategy,
    double alpha,
    int n,
    bool saveTransitionMatrices,
    const std::string &outputDir,
    std::vector<Result>& flatResults,
    size_t idx,
    std::vector<std::atomic<int>>& failureCounts  // Add failureCounts vector
) {
    DEBUG_PRINT(1, "Replication:");
    if (DEBUG_LEVEL >= 1) std::cout << repl << '\n';

    std::random_device rd;
    std::mt19937 gen(rd());

    // Compute expected steps
    double expectedSteps = 0.0;
    double expectedPayoffPerStep = 0.0;
    double expectedTransitionsPerStep = 0.0;
    std::vector<std::vector<double>> transitionMatrix;

    if (!computeExpectedSteps(adjMatrix, strategy, alpha, gen, expectedSteps, expectedPayoffPerStep, expectedTransitionsPerStep, transitionMatrix)) {
        // Increment failure count
        ++failureCounts[idx];
        return;
    }

    // Save transition matrix if flag is set
    if (saveTransitionMatrices) {
        std::ostringstream alphaStrStream;
        alphaStrStream << std::fixed << std::setprecision(2) << alpha;
        std::string alphaStr = alphaStrStream.str();

        std::string strategyStr = strategyToString(strategy);
        std::string fileName = "transition_mat_" + adjMatrixToBinaryString(adjMatrix) + "_strategy_" + strategyStr + "_alpha_" + alphaStr + ".csv";
        std::string filePath = outputDir + "/" + fileName;
        writeMatrixToCSV(filePath, transitionMatrix);
    }

    // Store results directly into the pre-allocated vector
    flatResults[idx] = Result{n, adjMatrixToBinaryString(adjMatrix), alpha, strategy, repl, expectedSteps, expectedPayoffPerStep, expectedTransitionsPerStep};
}

int main(int argc, char* argv[]) {
    // Parse command line arguments
    bool saveTransitionMatrices = false;
    int numNodes = parseArgs(argc, argv, saveTransitionMatrices);
    int n = numNodes;
    int replications = 1;
    try {
        // Define alphas and strategies
        std::vector<double> alphas = {1.0};
        std::vector<Strategy> strategies = {Strategy::RandomLearning, Strategy::PayoffBasedLearning, Strategy::VygotskianLearning};
    
        // Prepare output directory
        std::string outputDir = "../output";
        if (!std::filesystem::exists(outputDir)) {
            std::filesystem::create_directory(outputDir);
        }
    
        // Read adjacency matrices
        std::vector<AdjacencyMatrix> adjacencyMatrices = readAdjacencyMatrices(n);
    
        std::cout << "Starting " << alphas.size() * strategies.size() * adjacencyMatrices.size() * 10 << " runs." << '\n';
    
        // Prepare the combinations
        std::vector<ParamCombination> combinations = makeCombinations(adjacencyMatrices, strategies, alphas, replications);
    
        std::vector<Result> flatResults(combinations.size());
        // Preallocate failure counts vector
        std::vector<std::atomic<int>> failureCounts(combinations.size());
    
        // Create indices for storing the results
        std::vector<size_t> indices(combinations.size());
        std::iota(indices.begin(), indices.end(), 0);
    
        // Process all combinations in parallel
        std::for_each(std::execution::par, indices.begin(), indices.end(), [&](size_t idx) {
            const ParamCombination& comb = combinations[idx];
            DEBUG_PRINT(1, "Adjacency Matrix:");
            if(DEBUG_LEVEL >= 1) std::cout << comb.adjMatrixBinary << '\n';
            DEBUG_PRINT(1, "Strategy:");
            if(DEBUG_LEVEL >= 1) std::cout << strategyToString(comb.strategy) << '\n';
            DEBUG_PRINT(1, "Alpha:");
            if(DEBUG_LEVEL >= 1) std::cout << comb.alpha << '\n';
    
            processRepl(
                comb.repl,
                comb.adjMatrix,
                comb.strategy,
                comb.alpha,
                n,
                saveTransitionMatrices,
                outputDir,
                flatResults,
                idx,
                failureCounts  
            );
        });
    
        // Compute total failures
        int totalFailures = 0;
        for (const auto& count : failureCounts) {
            totalFailures += count.load();
        }
    
        // Print total number of failures with debug level 0
        DEBUG_PRINT(0, "Total failures: " << totalFailures);
    
        // Prepare CSV data with header
        std::string csvHeader = "num_nodes,adj_mat,alpha,strategy,repl,steps,step_payoff,step_transitions";
        std::vector<std::string> csvData;
        csvData.push_back(csvHeader);
    
        for (const auto& result : flatResults) {
            std::string formattedResult = formatResults(
                result.n,
                result.adjMatrixBinary,
                result.alpha,
                result.strategy,
                result.repl,
                result.expectedSteps,
                result.expectedPayoffPerStep,
                result.expectedTransitionsPerStep
            );
            csvData.push_back(formattedResult);
        }
    
        writeAndCompressCSV(outputDir, n, csvData);
       
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << '\n';
        return 1;
    }
    
    return 0;
}#include "Payoffs.hpp"
#include <random>


PayoffVector generatePayoffs(const std::vector<int>& distances, double alpha, std::mt19937& gen) {
    std::uniform_real_distribution<double> dist(0.0, 1.0);

    PayoffVector payoffs(distances.size());

    for (size_t i = 0; i < distances.size(); ++i) {
        if (distances[i] == 0) {
            payoffs[i] = 0.0;
        } else {
            double randValue = dist(gen);
            double payoff = randValue + alpha * distances[i];
            payoffs[i] = payoff;
        }
    }

    return payoffs;
}#include "Utils.hpp"
#include "Types.hpp"
#include <fstream>
#include <iomanip>
#include <stdexcept>
#include <iostream>
#include <cstdio>
#include <zlib.h>

void writeMatrixToCSV(const std::string& filename, const std::vector<std::vector<double>>& matrix) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open file " + filename);
    }

    for (const auto& row : matrix) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << std::fixed << std::setprecision(2) << row[i];
            if (i < row.size() - 1) file << ',';
        }
        file << '\n';
    }
}

std::string strategyToString(Strategy strategy) {
    switch (strategy) {
        case RandomLearning:
            return "RandomLearning";
        case PayoffBasedLearning:
            return "PayoffBasedLearning";
        case VygotskianLearning:
            return "VygotskianLearning";
        default:
            throw std::invalid_argument("Unknown strategy");
    }
}

std::string formatResults(int n, const std::string& adjMatrixBinary, double alpha, Strategy strategy, int repl, double expectedSteps, double expectedPayoffPerStep, double expectedTransitionsPerStep) {
    std::ostringstream oss;
    oss << n << ',' << adjMatrixBinary << ',' << alpha << ',' << strategyToString(strategy) << ',' << repl << ',' << std::fixed << std::setprecision(4) << expectedSteps << ',' << expectedPayoffPerStep << ',' << expectedTransitionsPerStep;
    return oss.str();
}

std::vector<AdjacencyMatrix> readAdjacencyMatrices(int n) {
    std::string filePath = "../data/data_new/adj_mat_" + std::to_string(n) + ".csv";
    std::ifstream file(filePath);
    if (!file.is_open()) throw std::runtime_error("Could not open file " + filePath);

    std::vector<AdjacencyMatrix> matrices;
    std::string line;
    while (std::getline(file, line)) {
        matrices.push_back(binaryStringToAdjacencyMatrix(n, line));
    }
    
    std::cout << "Loaded " << matrices.size() << " adjacency matrices." << '\n';

    return matrices;
}

AdjacencyMatrix binaryStringToAdjacencyMatrix(int n, const std::string& str) {
    std::string binaryStr = str;

    if (binaryStr.length() != static_cast<size_t>(n * n)) {
        throw std::invalid_argument("Invalid length: Expected " + std::to_string(n * n) + 
                                    " bits, got " + std::to_string(binaryStr.length()));
    }

    AdjacencyMatrix matrix(n, std::vector<bool>(n));
    for (int row = 0; row < n; ++row) {
        for (int column = 0; column < n; ++column) {
            matrix[row][column] = charToBool(binaryStr[row * n + column]);
        }
    }

    return matrix;
}

bool charToBool(char c) {
    if (c == '0') return false;
    if (c == '1') return true;
    throw std::invalid_argument("Invalid character in adjacency matrix: Expected '0' or '1', got " + std::string(1, c));
}


void printMatrix(const std::vector<std::vector<double>>& matrix) {
    for (const auto& row : matrix) {
        for (const auto& element : row) {
            std::cout << std::setw(10) << std::fixed << std::setprecision(2) << element << " ";
        }
        std::cout << '\n';
    }
}

int parseArgs(int argc, char* argv[], bool& saveTransitionMatrices) {
    int numNodes = 4;  // Default value
    saveTransitionMatrices = false;  // Default value

    if (argc == 1) {
        // Use default values
    } else if (argc == 2) {
        numNodes = std::stoi(argv[1]);
    } else if (argc == 3) {
        numNodes = std::stoi(argv[1]);
        std::string arg2 = argv[2];
        if (arg2 == "True") {
            saveTransitionMatrices = true;
        } else if (arg2 == "False") {
            saveTransitionMatrices = false;
        } else {
            throw std::invalid_argument("Second argument must be True or False.");
        }
    } else {
        throw std::invalid_argument("Usage: program [numNodes] [saveTransitionMatrices]");
    }

    return numNodes;
}

void writeAndCompressCSV(const std::string& outputDir, int n, const std::vector<std::string>& csvData) {
    // Construct the output CSV file path
    std::string outputCsvPath = outputDir + "/expected_steps_" + std::to_string(n) + ".csv";

    // Write results to CSV
    std::ofstream csvFile(outputCsvPath);
    if (!csvFile.is_open()) {
        std::cerr << "Failed to open file for writing: " << outputCsvPath << '\n';
        return;
    }
    for (const auto& line : csvData) {
        csvFile << line << "\n";
    }
    csvFile.close();

    // Compress the CSV file using gzip
    std::string compressedFilePath = outputCsvPath + ".gz";
    FILE* source = fopen(outputCsvPath.c_str(), "rb");
    gzFile dest = gzopen(compressedFilePath.c_str(), "wb");
    if ((source == nullptr) || (dest == nullptr)) {
        std::cerr << "Failed to open files for compression\n";
        if (source != nullptr) fclose(source);
        if (dest != nullptr) gzclose(dest);
        return;
    }

    char buffer[8192];
    int bytesRead = 0;
    while ((bytesRead = fread(buffer, 1, sizeof(buffer), source)) > 0) {
        gzwrite(dest, buffer, bytesRead);
    }

    fclose(source);
    gzclose(dest);

    // Remove the original uncompressed file
    if (std::remove(outputCsvPath.c_str()) != 0) {
        std::cerr << "Failed to remove original file: " << outputCsvPath << '\n';
    }

    std::cout << "Expected steps to absorption saved and compressed to '" << compressedFilePath << "'\n";
}

std::string adjMatrixToBinaryString(const AdjacencyMatrix& adjMatrix) {
    std::string binaryString;
    binaryString.reserve(adjMatrix.size() * adjMatrix[0].size());

    for (const auto& row : adjMatrix) {
        for (bool entry : row) {
            binaryString += entry ? '1' : '0';
        }
    }
    return binaryString;
}

std::vector<ParamCombination> makeCombinations(std::vector<AdjacencyMatrix>& adjacencyMatrices, std::vector<Strategy>& strategies, std::vector<double>& alphas, int replications) {
    std::vector<ParamCombination> combinations;
    for (const auto& adjMatrix : adjacencyMatrices) {
        std::string adjMatrixBinary = adjMatrixToBinaryString(adjMatrix);
        for (const auto& strategy : strategies) {
            for (const auto& alpha : alphas) {
                for (int repl = 0; repl < replications; ++repl) {
                    combinations.push_back({adjMatrix, adjMatrixBinary, strategy, alpha, repl});
                }
            }
        }
    }
    return combinations;
};